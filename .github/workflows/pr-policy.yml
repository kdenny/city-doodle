name: PR Policy

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-pr:
    name: Validate PR
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Check ticket reference
        id: ticket
        uses: actions/github-script@v8
        with:
          script: |
            const title = context.payload.pull_request.title;
            const body = context.payload.pull_request.body || '';
            const branch = context.payload.pull_request.head.ref;

            // Standard patterns to match ticket references
            const patterns = [
              /[A-Z]+-\d+/,           // PROJ-123 (Linear, Jira)
              /SC-\d+/i,              // SC-12345 (Shortcut)
              /\#\d+/,                // #123 (GitHub issues)
              /issues\/\d+/,          // issues/123 (GitHub)
            ];

            // Grandfathered patterns for legacy tickets
            // Add custom patterns here for pre-existing ticket formats
            const grandfatheredPatterns = [
              /\[LEGACY-\d+\]/i,      // [LEGACY-123]
              /BACKLOG-\d+/i,         // BACKLOG-123
              /^\d+-/,                // 123-description (numeric prefix)
            ];

            const allPatterns = [...patterns, ...grandfatheredPatterns];

            const hasTicket = allPatterns.some(p =>
              p.test(title) || p.test(body) || p.test(branch)
            );

            if (!hasTicket) {
              core.warning('No ticket reference found in PR title, body, or branch name');
              core.setOutput('has_ticket', 'false');
            } else {
              core.setOutput('has_ticket', 'true');
            }

      - name: Check branch naming
        uses: actions/github-script@v8
        with:
          script: |
            const branch = context.payload.pull_request.head.ref;

            // Skip for common branch names
            const skipBranches = ['main', 'master', 'develop', 'staging', 'release', 'hotfix'];
            if (skipBranches.includes(branch)) {
              return;
            }

            // Standard branch patterns
            const standardPatterns = [
              /^[A-Z]+-\d+/,          // PROJ-123 (Linear, Jira)
              /^SC-\d+/i,             // SC-12345 (Shortcut)
              /^\d+-/,                // 123-description (GitHub issue)
            ];

            // Grandfathered branch patterns for legacy projects
            const grandfatheredPatterns = [
              /^feature\//,           // feature/some-name
              /^bugfix\//,            // bugfix/some-name
              /^hotfix\//,            // hotfix/some-name
              /^fix\//,               // fix/some-name
              /^chore\//,             // chore/some-name
            ];

            const allPatterns = [...standardPatterns, ...grandfatheredPatterns];
            const matchesPattern = allPatterns.some(p => p.test(branch));

            if (!matchesPattern) {
              core.warning(`Branch name "${branch}" doesn't follow convention. Expected: PROJ-123, SC-12345, or feature/description`);
            }

      - name: Post summary comment
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const hasTicket = '${{ steps.ticket.outputs.has_ticket }}' === 'true';

            let issues = [];
            if (!hasTicket) issues.push('- Missing ticket reference in title, body, or branch');

            if (issues.length > 0) {
              const body = `## PR Policy Check

            The following items need attention:

            ${issues.join('\n')}

            Please update your PR to address these items.`;

              // Check if we already have a comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
              });

              const botComment = comments.find(c =>
                c.user.type === 'Bot' &&
                c.body.includes('PR Policy Check')
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: body,
                });
              }
            }
